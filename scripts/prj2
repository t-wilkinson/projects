#!/usr/bin/env python3
"""
prj - Manage your local git repositories with ease.
"""
import argparse
import json
import os
import shutil
import subprocess
import sys
import re
from signal import signal, SIGPIPE, SIG_DFL

# Ignore SIGPIPE errors when piping output (e.g., to `head` or `grep`)
try:
    signal(SIGPIPE, SIG_DFL)
except AttributeError: # SIGPIPE may not be available on all platforms (e.g. Windows)
    pass


# --- Configuration and Setup ---

def get_config_paths():
    """Determines project directory and config file paths."""
    prj_dir_env = os.environ.get('PRJ_DIR')
    if prj_dir_env:
        # Resolve ~ and ../.. etc. if present in PRJ_DIR
        prj_dir = os.path.abspath(os.path.expanduser(prj_dir_env))
    else:
        prj_dir = os.path.expanduser('~/dev')

    config_file_env = os.environ.get('PRJ_CONFIG')
    if config_file_env:
        config_file_path = os.path.abspath(os.path.expanduser(config_file_env))
        config_dir = os.path.dirname(config_file_path)
    else:
        config_dir = os.path.expanduser('~/.config/prj')
        config_file_path = os.path.join(config_dir, 'config.json')
        
    return prj_dir, config_dir, config_file_path

PRJ_DIR, CONFIG_DIR, CONFIG_FILE = get_config_paths()

def get_git_remote_url(repo_path):
    """Gets the remote URL of a git repository."""
    try:
        result = subprocess.run(
            ['git', 'config', '--get', 'remote.origin.url'],
            cwd=repo_path,
            capture_output=True, text=True, check=False # check=False to handle no remote
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass # git not found or not a git repo or other git error
    return ""

def get_project_key_from_url(git_url):
    """Extracts 'author/repository' from a git URL (primarily GitHub)."""
    # Handles https://github.com/author/repo.git and git@github.com:author/repo.git
    match = re.search(r'(?:[:/])([^/]+)/([^/]+?)(?:\.git)?$', git_url)
    if match:
        author, repo = match.groups()
        return f"{author}/{repo}"
    return None


def init_prj_environment(force_rescan=False):
    """Initializes project directory and config file.
    Scans PRJ_DIR for existing git repositories if config is new or force_rescan is True.
    """
    os.makedirs(PRJ_DIR, exist_ok=True)
    os.makedirs(CONFIG_DIR, exist_ok=True)

    if not os.path.isfile(CONFIG_FILE) or force_rescan:
        if force_rescan:
            print(f"Rescanning {PRJ_DIR} and rebuilding config at {CONFIG_FILE}...")
            existing_config_data = load_config(CONFIG_FILE, silent=True) # Load existing to preserve settings
            if existing_config_data is None: # If config was corrupted or truly missing
                 existing_config_data = {"settings": {"PRJ_DIR_snapshot": PRJ_DIR}, "projects": {}}
        else:
            print(f"Config file not found at {CONFIG_FILE}. Creating a new one.")
            existing_config_data = {"settings": {"PRJ_DIR_snapshot": PRJ_DIR}, "projects": {}}
        
        projects = existing_config_data.get("projects", {}) # Start with existing projects if rescanning
        
        if os.path.isdir(PRJ_DIR):
            print(f"Scanning {PRJ_DIR} for existing git projects...")
            for author_name in os.listdir(PRJ_DIR):
                author_path = os.path.join(PRJ_DIR, author_name)
                if os.path.isdir(author_path) and not author_name.startswith('.'):
                    for repo_name in os.listdir(author_path):
                        repo_path = os.path.join(author_path, repo_name)
                        if os.path.isdir(os.path.join(repo_path, '.git')):
                            project_key = f"{author_name}/{repo_name}"
                            if project_key not in projects: # Add only if not already known
                                print(f"Found project: {project_key}")
                                projects[project_key] = {
                                    "author": author_name,
                                    "repository": repo_name,
                                    "aliases": [],
                                    "tags": [],
                                    "remote_url": get_git_remote_url(repo_path) or f"https://github.com/{project_key}.git",
                                    "description": ""
                                }
                            elif projects[project_key].get("remote_url", "") == "":
                                # If known project has no remote_url, try to update it
                                projects[project_key]["remote_url"] = get_git_remote_url(repo_path) or f"https://github.com/{project_key}.git"


        # Clean up: Remove projects from config if their directory no longer exists
        if force_rescan:
            keys_to_remove = []
            for key, data in projects.items():
                author = data.get("author", key.split('/')[0])
                repo = data.get("repository", key.split('/')[-1])
                project_path = os.path.join(PRJ_DIR, author, repo)
                if not os.path.isdir(project_path) or not os.path.isdir(os.path.join(project_path, '.git')):
                    print(f"Project directory for '{key}' not found at '{project_path}'. Removing from config.")
                    keys_to_remove.append(key)
            for key in keys_to_remove:
                del projects[key]

        config_data = {
            "settings": existing_config_data.get("settings", {"PRJ_DIR_snapshot": PRJ_DIR}),
            "projects": projects
        }
        config_data["settings"]["PRJ_DIR_snapshot"] = PRJ_DIR # Update snapshot
        save_config(config_data, CONFIG_FILE)
        print(f"Initialization complete. Config saved to {CONFIG_FILE}")
    return PRJ_DIR, CONFIG_FILE


def load_config(config_file_path, silent=False):
    """Loads the JSON configuration file."""
    try:
        with open(config_file_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        if not silent:
            print(f"Info: Config file {config_file_path} not found. Run 'prj init' or 'prj sync'.", file=sys.stderr)
        return None # Expected if called before init
    except json.JSONDecodeError:
        print(f"Error: Config file {config_file_path} is corrupted. Please fix or delete it and run 'prj init'.", file=sys.stderr)
        sys.exit(1)

def save_config(config_data, config_file_path):
    """Saves the configuration data to the JSON file."""
    try:
        with open(config_file_path, 'w') as f:
            json.dump(config_data, f, indent=2)
    except IOError as e:
        print(f"Error: Could not write to config file {config_file_path}: {e}", file=sys.stderr)
        sys.exit(1)

# --- Project Resolution ---

def resolve_project(identifier, config_projects):
    """
    Resolves a project identifier (author/repo, alias, or repo name)
    to its canonical 'author/repository' key.
    """
    if not identifier:
        return None

    # 1. Exact match for 'author/repository' key
    if identifier in config_projects:
        return identifier

    # 2. Alias match
    for key, data in config_projects.items():
        if identifier in data.get("aliases", []):
            return key

    # 3. Repository name match (if identifier doesn't contain '/')
    if '/' not in identifier:
        matches = []
        for key, data in config_projects.items():
            # Check actual repository name and also the repo part of the key
            if data.get("repository", "").lower() == identifier.lower() or \
               key.split('/')[-1].lower() == identifier.lower():
                matches.append(key)
        
        if len(matches) == 1:
            return matches[0]
        elif len(matches) > 1:
            print(f"Error: Ambiguous project identifier '{identifier}'. Matches found:", file=sys.stderr)
            for m in matches:
                print(f"  - {m}", file=sys.stderr)
            print("Please use a more specific identifier (author/repository or a unique alias).", file=sys.stderr)
            return None # Ambiguous

    # 4. If identifier is 'author/repo' format but not found (e.g., a typo or not installed)
    if '/' in identifier and identifier not in config_projects:
        # Check if it's an alias that happens to have a slash (less common)
        # This was already checked in step 2, so if we are here, it's not a known alias.
        pass # Will fall through to return None

    return None # Not found


def get_project_path(project_key, config_data):
    """Gets the full path to a project given its key."""
    project_info = config_data["projects"].get(project_key)
    if not project_info:
        return None
    # Use author/repository from project_info if available, otherwise parse from key
    author = project_info.get("author", project_key.split('/')[0])
    repository = project_info.get("repository", project_key.split('/')[-1])
    return os.path.join(PRJ_DIR, author, repository)


def get_target_projects(args_project_identifiers, config_projects, all_if_empty=True):
    """Resolves multiple project identifiers, or all projects if list is empty."""
    if not args_project_identifiers:
        if all_if_empty:
            return sorted(list(config_projects.keys()))
        else:
            return []

    resolved_targets = []
    for p_id in args_project_identifiers:
        resolved = resolve_project(p_id, config_projects)
        if resolved:
            resolved_targets.append(resolved)
        else:
            # Error message already printed by resolve_project if ambiguous
            if not any(p_id in m for m in ["Error: Ambiguous project identifier", "not found"]): # Avoid double printing
                 print(f"Warning: Project '{p_id}' not found. Skipping.", file=sys.stderr)
    return sorted(list(set(resolved_targets))) # Unique and sorted

# --- Git Operations ---

def run_git_command(project_path, command_args, display_output=True):
    """Runs a git command in the specified project directory."""
    if not os.path.isdir(os.path.join(project_path, '.git')):
        print(f"Skipping {os.path.basename(project_path)}: Not a git repository or .git folder missing.", file=sys.stderr)
        return False
    try:
        # Using Popen for potentially long-running commands and streaming output
        process = subprocess.Popen(['git'] + command_args, cwd=project_path, 
                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        if display_output:
            # Stream stdout
            for line in process.stdout:
                sys.stdout.write(line)
            sys.stdout.flush()
        
        # Wait for the process to complete and capture stderr
        stdout, stderr = process.communicate() # stdout will be empty if already read

        if process.returncode != 0:
            if display_output and stderr: # Print stderr if not already captured by stdout loop (some git commands use stderr for progress)
                print(f"Git command error in {project_path}:\n{stderr.strip()}", file=sys.stderr)
            elif not display_output and stderr: # For non-display calls, still show error
                 print(f"Error in {project_path} (git {' '.join(command_args)}):\n{stderr.strip()}", file=sys.stderr)
            return False
        return True
    except FileNotFoundError:
        print("Error: 'git' command not found. Please ensure Git is installed and in your PATH.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred while running git command in {project_path}: {e}", file=sys.stderr)
        return False

# --- Command Functions ---

def cmd_init(args, config_data):
    """Command: prj init"""
    # init_prj_environment is called at the start, so this command mainly serves as an explicit way to create/check.
    # We can add a force re-scan or re-init option if needed.
    print(f"Project directory: {PRJ_DIR}")
    print(f"Config file: {CONFIG_FILE}")
    if not os.path.isfile(CONFIG_FILE):
        print("Config file was not found, it should have been created.")
        print("Running initialization again...")
        init_prj_environment() # Ensure it's created
    else:
        print("Environment is initialized.")
        if args.rescan:
            init_prj_environment(force_rescan=True)


def cmd_install(args, config_data):
    """Command: prj install <repo_url_or_author_repo>"""
    repo_identifier = args.repo_identifier
    
    if "://" in repo_identifier or "@" in repo_identifier: # Likely a full URL
        clone_url = repo_identifier
        project_key_from_url = get_project_key_from_url(clone_url)
        if not project_key_from_url:
            print(f"Error: Could not parse author/repository from URL: {clone_url}", file=sys.stderr)
            print("Please provide a standard git URL or use 'author/repository' format.", file=sys.stderr)
            return
        author, repository = project_key_from_url.split('/')
    elif '/' in repo_identifier: # author/repository format
        author, repository = repo_identifier.split('/', 1)
        clone_url = args.source_url_template.format(author=author, repository=repository)
    else:
        print("Error: Invalid repository identifier. Use 'author/repository' or a full Git URL.", file=sys.stderr)
        return

    project_key = f"{author}/{repository}"
    target_dir = os.path.join(PRJ_DIR, author, repository)

    if project_key in config_data["projects"] and os.path.isdir(target_dir):
        print(f"Project {project_key} already exists at {target_dir} and is in config.", file=sys.stderr)
        return

    if os.path.isdir(target_dir):
        print(f"Warning: Directory {target_dir} already exists.", file=sys.stderr)
        if not os.path.isdir(os.path.join(target_dir, '.git')):
            print(f"Error: {target_dir} exists but is not a git repository. Please remove it or choose a different location.", file=sys.stderr)
            return
        print("Assuming it's the project. Adding to config if not present.")
    else:
        print(f"Cloning {clone_url} into {target_dir}...")
        os.makedirs(os.path.dirname(target_dir), exist_ok=True)
        try:
            subprocess.run(['git', 'clone', clone_url, target_dir], check=True, capture_output=True, text=True)
            print(f"Successfully cloned {project_key}.")
        except subprocess.CalledProcessError as e:
            print(f"Error cloning repository {clone_url}:", file=sys.stderr)
            print(e.stderr, file=sys.stderr)
            # Clean up failed clone attempt if directory was created
            if os.path.exists(target_dir) and not os.listdir(target_dir):
                shutil.rmtree(target_dir, ignore_errors=True)
                if not os.listdir(os.path.dirname(target_dir)): # remove author dir if empty
                    shutil.rmtree(os.path.dirname(target_dir), ignore_errors=True)
            return
        except FileNotFoundError:
            print("Error: 'git' command not found. Please ensure Git is installed.", file=sys.stderr)
            sys.exit(1)

    # Add or update project in config
    project_entry = config_data["projects"].get(project_key, {})
    project_entry.update({
        "author": author,
        "repository": repository,
        "remote_url": clone_url if "://" in clone_url else get_git_remote_url(target_dir) or clone_url, # Prefer actual remote if possible
        "description": project_entry.get("description", "") # Keep existing description
    })
    if "aliases" not in project_entry: project_entry["aliases"] = []
    if "tags" not in project_entry: project_entry["tags"] = []

    if args.alias:
        if args.alias not in project_entry["aliases"]:
            project_entry["aliases"].append(args.alias)
            print(f"Added alias '{args.alias}' for {project_key}.")

    config_data["projects"][project_key] = project_entry
    save_config(config_data, CONFIG_FILE)
    print(f"Project {project_key} added to configuration.")


def cmd_uninstall(args, config_data):
    """Command: prj uninstall <project_identifier>"""
    project_key = resolve_project(args.project_identifier, config_data["projects"])
    if not project_key:
        print(f"Error: Project '{args.project_identifier}' not found in configuration.", file=sys.stderr)
        return

    project_path = get_project_path(project_key, config_data)

    del config_data["projects"][project_key]
    save_config(config_data, CONFIG_FILE)
    print(f"Project {project_key} removed from configuration.")

    if args.delete_files:
        if project_path and os.path.isdir(project_path):
            try:
                print(f"Deleting project files from {project_path}...")
                shutil.rmtree(project_path)
                print(f"Successfully deleted {project_path}.")
                # Attempt to remove author directory if it's empty
                author_dir = os.path.dirname(project_path)
                if os.path.exists(author_dir) and not os.listdir(author_dir):
                    shutil.rmtree(author_dir)
                    print(f"Removed empty author directory: {author_dir}")
            except OSError as e:
                print(f"Error deleting project files: {e}", file=sys.stderr)
        else:
            print(f"Project files for {project_key} not found at expected path or path is invalid.", file=sys.stderr)


def cmd_ls(args, config_data):
    """Command: prj ls"""
    projects_to_list = []
    if not config_data or not config_data.get("projects"):
        print("No projects found in configuration. Try 'prj sync' or 'prj install'.")
        return

    for key, data in sorted(config_data["projects"].items()):
        if args.author and data.get("author", "").lower() != args.author.lower():
            continue
        if args.tag and args.tag not in data.get("tags", []):
            continue
        
        projects_to_list.append((key, data))

    if not projects_to_list:
        print("No projects match your criteria.")
        return

    for key, data in projects_to_list:
        output = key
        if args.path:
            project_path = get_project_path(key, config_data)
            output = project_path if project_path else f"{key} (path not found)"
        elif args.long:
            details = []
            if data.get("aliases"):
                details.append(f"aliases: {', '.join(data['aliases'])}")
            if data.get("tags"):
                details.append(f"tags: {', '.join(data['tags'])}")
            if data.get("description"):
                 details.append(f"desc: {data['description'][:50]}{'...' if len(data['description']) > 50 else ''}")
            if details:
                output += f" ({'; '.join(details)})"
        print(output)


def cmd_git_operation(args, config_data, operation_name, git_command_args_list):
    """Generic handler for status, pull, push."""
    target_keys = get_target_projects(args.project_identifiers, config_data["projects"])
    if not target_keys:
        if args.project_identifiers: # Some were specified but not found
            print("No valid projects to operate on from your selection.")
        else: # No projects specified, and none in config
            print("No projects configured to operate on.")
        return

    print(f"Performing '{operation_name}' on {len(target_keys)} project(s)...")
    success_count = 0
    failure_count = 0
    for key in target_keys:
        project_path = get_project_path(key, config_data)
        if project_path and os.path.isdir(project_path):
            print(f"\n--- {operation_name.capitalize()} for {key} ({project_path}) ---")
            if run_git_command(project_path, git_command_args_list):
                success_count += 1
            else:
                failure_count +=1
        else:
            print(f"Skipping {key}: Path not found or invalid ({project_path})", file=sys.stderr)
            failure_count +=1
    
    print(f"\n--- {operation_name.capitalize()} Summary ---")
    print(f"Successful operations: {success_count}")
    print(f"Failed/skipped operations: {failure_count}")


def cmd_status(args, config_data):
    """Command: prj status"""
    cmd_git_operation(args, config_data, "status", ['status', '-sb'])

def cmd_pull(args, config_data):
    """Command: prj pull"""
    pull_args = ['pull']
    if args.rebase:
        pull_args.append('--rebase')
    if args.ff_only:
        pull_args.append('--ff-only')
    cmd_git_operation(args, config_data, "pull", pull_args)

def cmd_push(args, config_data):
    """Command: prj push"""
    push_args = ['push']
    if args.force:
        push_args.append('--force')
    # Add more push options as needed, e.g., --tags, specific remote/branch
    cmd_git_operation(args, config_data, "push", push_args)


def cmd_cd(args, config_data):
    """Command: prj cd <project_identifier_or_author>"""
    identifier = args.identifier
    target_path = None

    # Try resolving as a project first
    project_key = resolve_project(identifier, config_data["projects"])
    if project_key:
        target_path = get_project_path(project_key, config_data)
    else:
        # Try resolving as an author directory
        potential_author_path = os.path.join(PRJ_DIR, identifier)
        if os.path.isdir(potential_author_path):
            # Check if 'identifier' is indeed an author by seeing if it has subdirs that are projects
            is_author = False
            for proj_key, proj_data in config_data["projects"].items():
                if proj_data.get("author") == identifier:
                    is_author = True
                    break
            if is_author:
                 target_path = potential_author_path
            else:
                # Could be an author dir that has no *managed* projects yet
                # Or just a subdir in PRJ_DIR that matches the name.
                # For now, be strict: if not a known project, and not an author with managed projects, don't cd.
                pass


    if target_path and os.path.isdir(target_path):
        # Critical: Only print the path to stdout for shell `cd $(...)` to work
        print(target_path)
    else:
        print(f"Error: Could not find directory for '{identifier}'. Not a known project, alias, or author directory with managed projects.", file=sys.stderr)
        sys.exit(1) # Important for `cd $(...)` to not change to home dir on error


def cmd_show(args, config_data):
    """Command: prj show"""
    depth = args.depth
    print(f"{PRJ_DIR}/")
    
    authors = sorted([d for d in os.listdir(PRJ_DIR) if os.path.isdir(os.path.join(PRJ_DIR, d)) and not d.startswith('.')])
    
    for i, author_name in enumerate(authors):
        author_path = os.path.join(PRJ_DIR, author_name)
        is_last_author = (i == len(authors) - 1)
        author_prefix = "└── " if is_last_author else "├── "
        print(f"{author_prefix}{author_name}/")

        if depth > 1:
            repos = sorted([r for r in os.listdir(author_path) if os.path.isdir(os.path.join(author_path, r)) and not r.startswith('.')])
            for j, repo_name in enumerate(repos):
                # repo_path = os.path.join(author_path, repo_name) # Not strictly needed here
                is_last_repo = (j == len(repos) - 1)
                
                indent = "    " if is_last_author else "│   "
                repo_prefix = "└── " if is_last_repo else "├── "
                
                project_key = f"{author_name}/{repo_name}"
                marker = ""
                if project_key in config_data["projects"]:
                    p_data = config_data["projects"][project_key]
                    details = []
                    if p_data.get("aliases"): details.append(f"aliases: {', '.join(p_data['aliases'])}")
                    if p_data.get("tags"): details.append(f"tags: {', '.join(p_data['tags'])}")
                    if details: marker = f" ({'; '.join(details)})"
                elif os.path.isdir(os.path.join(author_path, repo_name, ".git")):
                    marker = " (unmanaged git repo)"
                else:
                    marker = " (directory)"


                print(f"{indent}{repo_prefix}{repo_name}{marker}")
                # Could add depth > 2 logic here if needed


def _modify_project_attribute(project_identifier, attribute_name, value, config_data, add=True):
    """Helper for adding/removing aliases and tags."""
    project_key = resolve_project(project_identifier, config_data["projects"])
    if not project_key:
        print(f"Error: Project '{project_identifier}' not found.", file=sys.stderr)
        return False

    project_data = config_data["projects"][project_key]
    if attribute_name not in project_data or not isinstance(project_data[attribute_name], list):
        project_data[attribute_name] = []

    attr_list = project_data[attribute_name]
    op_gerund = "Adding" if add else "Removing"
    op_past = "added" if add else "removed"

    if add:
        if value not in attr_list:
            attr_list.append(value)
            print(f"{attribute_name[:-1].capitalize()} '{value}' {op_past} to {project_key}.")
        else:
            print(f"{attribute_name[:-1].capitalize()} '{value}' already exists for {project_key}.")
            return True # Not an error, just no change
    else: # remove
        if value in attr_list:
            attr_list.remove(value)
            print(f"{attribute_name[:-1].capitalize()} '{value}' {op_past} from {project_key}.")
        else:
            print(f"Error: {attribute_name[:-1].capitalize()} '{value}' not found for {project_key}.", file=sys.stderr)
            return False
            
    save_config(config_data, CONFIG_FILE)
    return True

def cmd_alias(args, config_data):
    """Command: prj alias <project> <alias_name>"""
    _modify_project_attribute(args.project_identifier, "aliases", args.alias_name, config_data, add=True)

def cmd_unalias(args, config_data):
    """Command: prj unalias <project> <alias_name>"""
    _modify_project_attribute(args.project_identifier, "aliases", args.alias_name, config_data, add=False)

def cmd_tag(args, config_data):
    """Command: prj tag <project> <tag_name>"""
    _modify_project_attribute(args.project_identifier, "tags", args.tag_name, config_data, add=True)

def cmd_untag(args, config_data):
    """Command: prj untag <project> <tag_name>"""
    _modify_project_attribute(args.project_identifier, "tags", args.tag_name, config_data, add=False)


def cmd_export(args, config_data):
    """Command: prj export"""
    if not config_data["projects"]:
        print("No projects in configuration to export.", file=sys.stderr)
        return

    output_lines = []
    for key, data in sorted(config_data["projects"].items()):
        # Exporting the canonical 'author/repository' key is robust.
        # Alternatively, could export remote_url if always reliable.
        output_lines.append(key) 
        # output_lines.append(data.get("remote_url", f"https://github.com/{key}.git"))


    output_str = "\n".join(output_lines)
    if args.file:
        try:
            with open(args.file, 'w') as f:
                f.write(output_str + "\n")
            print(f"Exported {len(output_lines)} projects to {args.file}")
        except IOError as e:
            print(f"Error writing to file {args.file}: {e}", file=sys.stderr)
    else:
        print(output_str)


def cmd_import(args, config_data):
    """Command: prj import <filepath>"""
    filepath = args.filepath
    if not os.path.isfile(filepath):
        print(f"Error: Import file not found: {filepath}", file=sys.stderr)
        return

    try:
        with open(filepath, 'r') as f:
            lines = [line.strip() for line in f if line.strip() and not line.startswith('#')]
    except IOError as e:
        print(f"Error reading import file {filepath}: {e}", file=sys.stderr)
        return

    if not lines:
        print(f"No valid project identifiers found in {filepath}.")
        return
    
    print(f"Found {len(lines)} projects to import from {filepath}.")
    imported_count = 0
    skipped_count = 0
    failed_count = 0

    for line_num, repo_identifier in enumerate(lines, 1):
        print(f"\nProcessing line {line_num}: {repo_identifier}")
        # Simulate args for cmd_install
        install_args = argparse.Namespace(
            repo_identifier=repo_identifier, 
            alias=None, # Aliases aren't typically in simple export format
            source_url_template=args.source_url_template # from main parser
        )
        
        # Check if project already exists (by key or URL)
        project_key_from_id = None
        if "://" in repo_identifier or "@" in repo_identifier:
            project_key_from_id = get_project_key_from_url(repo_identifier)
        elif '/' in repo_identifier:
            project_key_from_id = repo_identifier
        
        if project_key_from_id and project_key_from_id in config_data["projects"]:
            target_dir_check = get_project_path(project_key_from_id, config_data)
            if os.path.isdir(target_dir_check):
                 print(f"Project {project_key_from_id} already configured and directory exists. Skipping.")
                 skipped_count += 1
                 continue
            else: # In config but dir missing, attempt re-install
                 print(f"Project {project_key_from_id} in config but directory missing. Attempting re-install.")


        try:
            # cmd_install will handle cloning and adding to config
            # It saves config internally, so config_data will be updated.
            cmd_install(install_args, config_data) 
            # Need to reload config_data if cmd_install modified it and we continue looping
            # However, cmd_install modifies the passed config_data dict in place.
            imported_count +=1
        except Exception as e:
            print(f"Failed to import {repo_identifier}: {e}", file=sys.stderr)
            failed_count += 1
            
    print("\n--- Import Summary ---")
    print(f"Successfully processed/installed: {imported_count}")
    print(f"Skipped (already exists): {skipped_count}")
    print(f"Failed: {failed_count}")


def cmd_search_remote(args, config_data):
    """Command: prj search-remote <github_username>"""
    try:
        import requests
    except ImportError:
        print("Error: The 'requests' library is required for this command.", file=sys.stderr)
        print("Please install it: pip install requests", file=sys.stderr)
        sys.exit(1)

    username = args.github_username
    api_url = f"https://api.github.com/users/{username}/repos"
    params = {'type': 'all', 'sort': 'updated', 'per_page': 100} # Get all, sort by updated

    try:
        print(f"Fetching repositories for GitHub user: {username}...")
        response = requests.get(api_url, params=params, timeout=10)
        response.raise_for_status() # Raise an exception for HTTP errors
        repos = response.json()

        if not repos:
            print(f"No public repositories found for user {username}.")
            return

        print(f"\nRepositories for {username} (newest first):")
        for repo in repos:
            name = repo.get("full_name") # author/repo
            description = repo.get("description") or "No description"
            stars = repo.get("stargazers_count", 0)
            fork = "[Fork] " if repo.get("fork") else ""
            
            already_installed = name in config_data["projects"]
            installed_marker = "*" if already_installed else " "
            
            print(f" {installed_marker} {name:<40} ({stars} ⭐) - {fork}{description[:80]}")
        print("\n(*) indicates the repository is already managed by prj.")

    except requests.exceptions.RequestException as e:
        print(f"Error fetching repositories for {username}: {e}", file=sys.stderr)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)

def cmd_sync(args, config_data):
    """Command: prj sync"""
    print("Synchronizing configuration with filesystem...")
    init_prj_environment(force_rescan=True) # This function now handles scan & cleanup logic
    print("Sync complete. Configuration file has been updated.")


# --- Main Execution ---

def main():
    # Ensure environment is set up before parsing args, as some defaults might depend on it.
    # However, CONFIG_FILE is needed for load_config.
    # init_prj_environment creates a default config if missing.
    # This means load_config should ideally not fail with FileNotFoundError if init is called first.
    
    # Initial call to ensure PRJ_DIR and config dir exist.
    # If config file doesn't exist, it creates a basic one (empty or scanned).
    init_prj_environment(force_rescan=False) # Don't force rescan on every command run
    config_data = load_config(CONFIG_FILE)

    if config_data is None: # Should only happen if init_prj_environment failed to create one
        print("Critical Error: Configuration could not be loaded or created. Exiting.", file=sys.stderr)
        # Attempt to create a very basic one if all else fails
        save_config({"settings": {"PRJ_DIR_snapshot": PRJ_DIR}, "projects": {}}, CONFIG_FILE)
        config_data = load_config(CONFIG_FILE) # Try loading again
        if config_data is None:
             sys.exit(1) # Truly give up

    parser = argparse.ArgumentParser(description="Manage your local git repositories.")
    parser.add_argument('--source-url-template', default="https://github.com/{author}/{repository}.git",
                        help="Template for Git clone URLs if not fully specified. Default: GitHub.")
    subparsers = parser.add_subparsers(dest='command', title='Available commands', help='Run `prj <command> -h` for more help.')
    subparsers.required = True


    # --- `init` command ---
    p_init = subparsers.add_parser('init', help="Initialize or re-initialize prj environment and config.")
    p_init.add_argument('--rescan', action='store_true', help="Force a rescan of PRJ_DIR and rebuild config.")
    p_init.set_defaults(func=cmd_init)

    # --- `install` command ---
    p_install = subparsers.add_parser('install', help="Clone a new repository and add to prj.")
    p_install.add_argument('repo_identifier', help="Repository to install (e.g., 'author/repo' or full git URL).")
    p_install.add_argument('--alias', help="Optional alias for the new project.")
    p_install.set_defaults(func=cmd_install)

    # --- `uninstall` command ---
    p_uninstall = subparsers.add_parser('uninstall', help="Remove a project from prj configuration.")
    p_uninstall.add_argument('project_identifier', help="Project to uninstall (key, alias, or repo name).")
    p_uninstall.add_argument('--delete-files', action='store_true', help="Also delete the project's files from disk.")
    p_uninstall.set_defaults(func=cmd_uninstall)

    # --- `ls` command ---
    p_ls = subparsers.add_parser('ls', help="List managed projects.")
    p_ls.add_argument('--author', help="Filter by author name.")
    p_ls.add_argument('--tag', help="Filter by tag.")
    p_ls.add_argument('-l', '--long', action='store_true', help="Show more details (aliases, tags, description).")
    p_ls.add_argument('-p', '--path', action='store_true', help="Show full local path instead of project key.")
    p_ls.set_defaults(func=cmd_ls)

    # --- `status` command ---
    p_status = subparsers.add_parser('status', help="Show git status for projects.")
    p_status.add_argument('project_identifiers', nargs='*', help="Specific projects (keys, aliases, repo names). All if empty.")
    p_status.set_defaults(func=cmd_status)

    # --- `pull` command ---
    p_pull = subparsers.add_parser('pull', help="Run git pull for projects.")
    p_pull.add_argument('project_identifiers', nargs='*', help="Specific projects. All if empty.")
    p_pull.add_argument('--rebase', action='store_true', help="Use 'git pull --rebase'.")
    p_pull.add_argument('--ff-only', action='store_true', help="Use 'git pull --ff-only'.")
    p_pull.set_defaults(func=cmd_pull)

    # --- `push` command ---
    p_push = subparsers.add_parser('push', help="Run git push for projects.")
    p_push.add_argument('project_identifiers', nargs='*', help="Specific projects. All if empty.")
    p_push.add_argument('--force', action='store_true', help="Use 'git push --force'.")
    p_push.set_defaults(func=cmd_push)
    
    # --- `cd` command ---
    p_cd = subparsers.add_parser('cd', help="Print path to project/author dir (for use with cd $(prj cd ...)).")
    p_cd.add_argument('identifier', help="Project (key, alias, repo name) or Author name.")
    p_cd.set_defaults(func=cmd_cd)

    # --- `show` command ---
    p_show = subparsers.add_parser('show', help="Display tree-like structure of PRJ_DIR.")
    p_show.add_argument('--depth', type=int, default=2, help="Depth of the tree to show (default: 2 for author/repo).")
    p_show.set_defaults(func=cmd_show)

    # --- `alias` command ---
    p_alias = subparsers.add_parser('alias', help="Add an alias to a project.")
    p_alias.add_argument('project_identifier', help="Project to alias (key, existing alias, or repo name).")
    p_alias.add_argument('alias_name', help="The new alias name.")
    p_alias.set_defaults(func=cmd_alias)

    # --- `unalias` command ---
    p_unalias = subparsers.add_parser('unalias', help="Remove an alias from a project.")
    p_unalias.add_argument('project_identifier', help="Project from which to remove alias.")
    p_unalias.add_argument('alias_name', help="The alias name to remove.")
    p_unalias.set_defaults(func=cmd_unalias)

    # --- `tag` command ---
    p_tag = subparsers.add_parser('tag', help="Add a tag to a project.")
    p_tag.add_argument('project_identifier', help="Project to tag.")
    p_tag.add_argument('tag_name', help="The tag name.")
    p_tag.set_defaults(func=cmd_tag)

    # --- `untag` command ---
    p_untag = subparsers.add_parser('untag', help="Remove a tag from a project.")
    p_untag.add_argument('project_identifier', help="Project from which to remove tag.")
    p_untag.add_argument('tag_name', help="The tag name to remove.")
    p_untag.set_defaults(func=cmd_untag)
    
    # --- `export` command ---
    p_export = subparsers.add_parser('export', help="Export list of managed projects.")
    p_export.add_argument('--file', help="Optional file to write the export list to (stdout if not provided).")
    p_export.set_defaults(func=cmd_export)

    # --- `import` command ---
    p_import = subparsers.add_parser('import', help="Import and install projects from a list file.")
    p_import.add_argument('filepath', help="Path to the file containing project identifiers (one per line).")
    p_import.set_defaults(func=cmd_import)

    # --- `search-remote` command ---
    p_search_remote = subparsers.add_parser('search-remote', help="Search for a GitHub user's public repositories.")
    p_search_remote.add_argument('github_username', help="GitHub username to search for.")
    p_search_remote.set_defaults(func=cmd_search_remote)

    # --- `sync` command ---
    p_sync = subparsers.add_parser('sync', help="Synchronize config with filesystem (scan PRJ_DIR, add new, warn about missing).")
    p_sync.set_defaults(func=cmd_sync)


    args = parser.parse_args()
    
    # Pass the loaded config_data to the command function
    # Most functions that modify config_data do so in-place and call save_config themselves.
    if hasattr(args, 'func'):
        args.func(args, config_data)
    else:
        parser.print_help() # Should not happen if subparsers.required = True

if __name__ == '__main__':
    main()

